#' Create a worker object for use as a worker with master objects generated by [QueryCountMaster()]
#' @description `QueryCountWorker` objects are worker objects at each site of
#' a distributed QueryCount model computation
#' @docType class
#' @seealso [QueryCountMaster()] which goes hand-in-hand with this object
#' @importFrom R6 R6Class
#' @section Methods:
#'
#' \describe{
#'   \item{`QueryCountWorker$new(defn, data)`}{Create a new QueryCount worker object with given definition defn, data and flag for preserving state between iterations}
#'   \item{`kosher()`}{Check if inputs and state of object are sane. For future use}
#'   \item{`getStateful()`}{Returns `FALSE`}
#' }
#'
#' @import rlang
#' @importFrom dplyr filter
#' @importFrom magrittr %>%
#' @export
#' @format An [R6::R6Class()] generator object
QueryCountWorker <- R6Class(
    "QueryCountWorker"
  , private = list(
        defn = NA
      , data = NA
      , stateful = FALSE
    )
  , public = list(
        initialize = function(defn, data, stateful = FALSE) {
            private$defn  <- defn
            private$data  <- data
            stopifnot(self$kosher())
        }, getStateful = function() {
            private$stateful
        }, kosher = function() {
            TRUE
        }, queryCount = function() {
            data  <- private$data
            filter_expr  <- eval(parse(text = paste("rlang::expr(", private$defn$filterCondition, ")")))
            data %>%
                dplyr::filter(!! filter_expr) %>%
                nrow()
        }
    )
)

#' Create a master object to control worker objects generated by [QueryCountWorker()]
#' @description `QueryCountMaster` objects instantiate and run a distributed QueryCount computation
#' @docType class
#' @seealso [QueryCountWorker()] which goes hand-in-hand with this object
#' @importFrom R6 R6Class
#' @section Methods:
#'
#' \describe{
#'   \item{`QueryCountMaster$new(defn, debug = FALSE)`}{Create an QueryCount master object
#'         with the specified computation definition. The debug flag is used for debugging computations}
#'   \item{`kosher()`}{Check if inputs and state of object are sane. For future use}
#'   \item{`run()`}{Run the QueryCount computation until either the
#'         threshold is reached or the max.iter number of iterations are used up}
#'   \item{`summary()`}{Return the summary of results}
#' }
#' @export
#' @format An [R6::R6Class()] generator object
QueryCountMaster <- R6Class(
    "QueryCountMaster",
    private = list(
        defn = NA,
        dry_run = FALSE,
        sites = list(),
        mapFn = function(site) {
            payload <- list(objectId = site$instanceId,
                            method = "queryCount")
            q <- POST(.makeOpencpuURL(urlPrefix=site$url, fn="executeMethod"),
                      body = toJSON(payload),
                      add_headers("Content-Type" = "application/json"),
                      config = getConfig()$sslConfig
                      )
            ## Should really examine result here.
            .deSerialize(q)
        },
        result_cache = list(),
        debug = FALSE
    ),
    public = list(
        initialize = function(defn, debug = FALSE) {
            'Initialize the object with a dataset'
            private$defn <- defn
            private$debug <- debug
            stopifnot(self$kosher())
        },
        kosher = function() {
            ' Check for appropriateness'
            TRUE
        }, queryCount = function() {
            'Compute the count'
            sites <- private$sites
            if (private$dry_run) {
                mapFn <- function(x) x$worker$queryCount()
            } else {
                mapFn <- private$mapFn
            }
            results <- Map(mapFn, sites)
            value <- Reduce(f = sum, results)
            if (private$debug) {
                print("value")
                print(value)
            }
            value
        },
        getSites = function() {
            private$sites
        },
        addSite = function(name, url = NULL, worker = NULL) {
            ## critical section start
            ## This is the time to cache "p" and check it
            ## against all added sites
            ## Only one of url/worker should be non-null
            stopifnot(is.null(url) || is.null(worker))
            n <- length(private$sites)
            if (is.null(url)) {
                private$dry_run <- private$dry_run || TRUE
                private$sites[[n+1]] <- list(name = name, worker = worker)
            } else {
                localhost <- (grepl("^http://localhost", url) ||
                              grepl("^http://127.0.0.1", url))
                private$sites[[n+1]] <- list(name = name, url = url,
                                             localhost = localhost,
                                             dataFileName = if (localhost) paste0(name, ".rds") else NULL)
            }
            ## critical section end
        },
        run = function() {
            'Run Computation'
            dry_run <- private$dry_run
            defn <- private$defn
            debug <- private$debug
            n <- length(sites)
            if (debug) {
                print("run(): checking worker object creation")
            }
            if (dry_run) {
                ## Workers have already been created and passed
                sites <- private$sites
            } else {
                ## Create an instance Id
                ## Make remote call to instantiate workers
                instanceId <- generateId(object=list(Sys.time(), self))
                ## Augment each site with object instance ids
                private$sites <- sites <- lapply(private$sites,
                                                 function(x) list(name = x$name,
                                                                  url = x$url,
                                                                  localhost = x$localhost,
                                                                  dataFileName = x$dataFileName,
                                                                  instanceId = if (x$localhost) x$name else instanceId))
                sitesOK <- sapply(sites,
                                  function(x) {
                                      payload <- if (is.null(x$dataFileName)) {
                                                     list(defnId = defn$id, instanceId = x$instanceId)
                                                 } else {
                                                     list(defnId = defn$id, instanceId = x$instanceId,
                                                          dataFileName = x$dataFileName)
                                                 }
                                      q <- POST(url = .makeOpencpuURL(urlPrefix=x$url, fn="createInstanceObject"),
                                                body = toJSON(payload),
                                                add_headers("Content-Type" = "application/json"),
                                                config = getConfig()$sslConfig
                                                )
                                      .deSerialize(q)
                                  })

                ## Stop on error
                if (!all(sitesOK)) {
                    stop("run():  Some sites did not respond successfully!")
                    sites <- sites[which(sitesOK)]  ## Only use sites that created objects successfully.
                }
            }
            private$result  <- result  <- self$queryCount()

            if (!dry_run) {
                if (debug) {
                    print("run(): checking worker object cleanup")
                }
                sitesOK <- sapply(sites,
                                  function(x) {
                                      payload <- list(instanceId = x$instanceId)
                                      q <- POST(url = .makeOpencpuURL(urlPrefix=x$url, fn="destroyInstanceObject"),
                                                body = toJSON(payload),
                                                add_headers("Content-Type" = "application/json"),
                                                config=getConfig()$sslConfig
                                                )
                                      .deSerialize(q)
                                  })
                if (!all(sitesOK)) {
                    warning("run():  Some sites did not clean up successfully!")
                }
            }
            result
        },
        summary = function() {
            'Return the summary'
            result <- private$result_cache
            if (length(result) == 0) {
                stop ("Run the computation first using run()")
                result <- private$result
            }
            result
        }
    )
)

#' Create a worker object for use as a worker with master objects generated by [HEQueryCountMaster()]
#' @description `HEQueryCountWorker` objects are worker objects at each site of
#' a distributed QueryCount model computation using homomorphic encryption
#' @docType class
#' @seealso [HEQueryCountMaster()] which goes hand-in-hand with this object
#' @importFrom R6 R6Class
#' @importFrom homomorpheR PaillierKeyPair
#' @section Methods:
#'
#' \describe{
#' \item{`HEQueryCountWorker$new(defn, data, pubkey, den)`}{Create a new HEQueryCount worker object with given
#'        definition defn, data, flag for preserving state between iterations, public key and denominator for rational approximations}
#' \item{`setParams(pubkey, den)`}{Set the public key and denominator for rational approximations}
#' }
#'
#' @import rlang
#' @importFrom dplyr filter
#' @importFrom magrittr %>%
#' @export
#' @format An [R6::R6Class()] generator object
HEQueryCountWorker <- R6Class(
    "HEQueryCountWorker",
    inherit = QueryCountWorker,
    private = list(
        result_cache = list()
    ),
    public = list(
        pubkey = NA, ## public key
        den = NA, ## denominator for rational approximations
        initialize = function(defn, data, pubkey_bits = NULL, pubkey_n = NULL, den_bits = NULL) {
            private$defn  <- defn
            private$data  <- data
            private$stateful <- TRUE
            if (!is.null(pubkey_bits)) {
                self$pubkey  <- homomorpheR::PaillierPublicKey$new(pubkey_bits, pubkey_n)
                self$den <- gmp::as.bigq(2)^(den_bits)  #Our denominator for rational approximations
            }
            stopifnot(self$kosher())
        },
        setParams = function(pubkey_bits, pubkey_n, den_bits) {
            if (!is.null(pubkey_bits)) {
                self$pubkey  <- homomorpheR::PaillierPublicKey$new(pubkey_bits, pubkey_n)
                self$den <- gmp::as.bigq(2)^(den_bits)  #Our denominator for rational approximations
            }
            TRUE
        },
        queryCount = function(partyNumber, token) {
            result  <- private$result_cache[[token]]
            if (is.null(result)) {
                ## we have to compute result for token
                result.int  <- super$queryCount()
                ## Add random quantity and encrypt
                pubkey <- self$pubkey
                ## Generate random offset for int and frac parts
                offset <- random.bigz(nBits = 256)
                zero  <- pubkey$encrypt(0)
                ncp1Result  <- list(int = pubkey$encrypt(result.int - offset), frac = zero)
                ncp2Result  <- list(int = pubkey$encrypt(result.int + offset), frac = zero)
                result  <- list(ncp1 = ncp1Result, ncp2 = ncp2Result)
                private$result_cache[[token]] <- result
            }
            if (partyNumber == 1) result$ncp1 else result$ncp2
        }
    )
)

#' Create a master object to control worker objects generated by [HEQueryCountWorker()]
#' @description `HEQueryCountMaster` objects instantiate and run a distributed homomorphic QueryCount computation
#' @docType class
#' @seealso [HEQueryCountWorker()] which goes hand-in-hand with this object
#' @importFrom R6 R6Class
#' @section Methods:
#'
#' \describe{
#'   \item{`HEQueryCountMaster$new(defn, debug = FALSE)`}{Create an HEQueryCount master object
#'         with the specified computation definition. The debug flag is used for debugging computations}
#'   \item{`run()`}{Run the QueryCount computation}
#' }
#' @export
#' @format An [R6::R6Class()] generator object
HEQueryCountMaster <- R6Class(
    "HEQueryCountMaster",
    inherit = QueryCountMaster,
    private = list(
        partyNumber = NA,
        defn = NA,
        mapFn = function(site, token) {
            payload <- list(objectId = site$instanceId,
                            method = "queryCount", partyNumber = private$partyNumber,
                            token = token)
            q <- POST(.makeOpencpuURL(urlPrefix=site$url, fn="executeHEMethod"),
                      body = toJSON(payload),
                      add_headers("Content-Type" = "application/json"),
                      config = getConfig()$sslConfig
                      )
            ## Should really examine result here.
            .deSerialize(q)
        },
        result = list(),
        debug = FALSE
    ),
    public = list(
        pubkey = NA,
        pubkey_bits = NA,
        pubkey_n = NA,
        den_bits = NA,
        den = NA,
        initialize = function(defn, partyNumber, debug = FALSE) {
            'Initialize the object with a dataset'
            private$defn <- defn
            private$partyNumber <- partyNumber
            private$debug <- debug
            stopifnot(self$kosher())
        },
        setParams = function(pubkey_bits, pubkey_n, den_bits) {
            self$pubkey_bits  <- pubkey_bits
            self$pubkey_n  <- pubkey_n
            self$den_bits  <- den_bits
            self$pubkey  <- homomorpheR::PaillierPublicKey$new(pubkey_bits, pubkey_n)
            self$den <- gmp::as.bigq(2)^(den_bits)  #Our denominator for rational approximations
            TRUE
        },
        kosher = function() {
            ' Check for appropriateness'
            TRUE
        }, queryCount = function(token) {
            'Compute the query count from all sites'
            sites <- private$sites
            if (private$dry_run) {
                mapFn <- function(site, token) site$worker$queryCount(private$partyNumber, token)
            } else {
                mapFn <- private$mapFn
            }
            results <- Map(mapFn, sites, rep(token, length(sites)))
            zero  <- pubkey$encrypt(0)
            intResults  <- lapply(results, function(x) x$int)
            fracResults  <- lapply(results, function(x) x$frac)
            intSum  <- Reduce(f = pubkey$add, x = intResults, init = zero)
            fracSum  <- Reduce(f = pubkey$add, x = fracResults, init = zero)
            list(int = intSum, frac = fracSum)
        },
        run = function(token) {
            'Run Computation'
            dry_run <- private$dry_run
            defn <- private$defn
            n <- length(sites)
            if (dry_run) {
                ## Workers have already been created and passed
                workers  <- lapply(sites, function(x) x$worker)
                ## We just need to set params on the sites
                for (worker in workers) {
                    worker$setParams(pubkey_bits = self$pubkey_bits, pubkey_n = self$pubkey_n, den_bits = self$den_bits)
                }
            } else {
                ## Create an instance Id
                ## Make remote call to instantiate workers
                instanceId <- generateId(object=list(Sys.time(), self))
                ## Augment each site with object instance ids
                private$sites <- sites <- lapply(private$sites,
                                                 function(x) list(name = x$name,
                                                                  url = x$url,
                                                                  localhost = x$localhost,
                                                                  dataFileName = x$dataFileName,
                                                                  instanceId = if (x$localhost) x$name else instanceId))
                sitesOK <- sapply(sites,
                                  function(x) {
                                      payload <- if (is.null(x$dataFileName)) {
                                                     list(defnId = defn$id, instanceId = x$instanceId,
                                                          pubkey_bits = self$pubkey_bits, pubkey_n = self$pubkey <- n, den_bits = self$den_bits)
                                                 } else {
                                                     list(defnId = defn$id, instanceId = x$instanceId,
                                                          dataFileName = x$dataFileName,
                                                          pubkey_bits = self$pubkey_bits, pubkey_n = self$pubkey <- n, den_bits = self$den_bits)
                                                 }
                                      q <- POST(url = .makeOpencpuURL(urlPrefix=x$url, fn="createInstanceObject"),
                                                body = toJSON(payload),
                                                add_headers("Content-Type" = "application/json"),
                                                config = getConfig()$sslConfig
                                                )
                                      .deSerialize(q)
                                  })

                ## Stop on error
                if (!all(sitesOK)) {
                    stop("run():  Some sites did not respond successfully!")
                    sites <- sites[which(sitesOK)]  ## Only use sites that created objects successfully.
                }
            }
            private$result  <- result  <- self$queryCount(token)

            if (!dry_run) {
                if (debug) {
                    print("run(): checking worker object cleanup")
                }
                sitesOK <- sapply(sites,
                                  function(x) {
                                      payload <- list(instanceId = x$instanceId)
                                      q <- POST(url = .makeOpencpuURL(urlPrefix=x$url, fn="destroyInstanceObject"),
                                                body = toJSON(payload),
                                                add_headers("Content-Type" = "application/json"),
                                                config=getConfig()$sslConfig
                                                )
                                      .deSerialize(q)
                                  })
                if (!all(sitesOK)) {
                    warning("run():  Some sites did not clean up successfully!")
                }
            }
            result
        },
        summary = function() {
            'Return the summary'
            result <- private$result
            if (length(result) == 0) {
                stop ("Run the computation first using run()")
                result <- private$result
            }
            result
        }
    )
)
